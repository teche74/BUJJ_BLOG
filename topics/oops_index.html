<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Buzz Blog</title>
  <link rel="stylesheet" href="../assets/css/oops_index.css">

</head>

<body>

  <header class="topic main_heading">Object Oriented Programming</header>

  <div class="note intro important-note">
    ‚ö†Ô∏è Heads up: Everything I share here is based on how I‚Äôve understood the concepts as a student. If anything seems
    off or confusing, feel free to reach out or cross-check it elsewhere. Learning is a two-way journey!
  </div>

  <!-- Introduction to OOP -->
  <div class="cloud-box">
    <p>
      Back in the early days of coding, most programs were written using something called <strong>procedural
        programming</strong>.
      This simply meant writing step-by-step instructions, like following a recipe. You define functions, give them
      data, and run them in order.
    </p>

    <p>
      While that worked fine for small programs, it got tricky as things got bigger. Since the code and the data it used
      were handled separately,
      managing complex programs became messy, especially when multiple parts needed to use or change the same data.
    </p>

    <p>
      To fix this, programmers came up with a better approach called <strong>Object-Oriented Programming (OOP)</strong>.
      It groups both data and related functions together into something called an <strong>object</strong>. This makes
      the code easier to organize, reuse, and understand.
    </p>
  </div>

  <!-- Classes -->
  <div class="classes cloud-box">
    <h1>Classes</h1>

    <p>
      A <strong>class</strong> is like a blueprint or template. It defines how something should behave and what it
      should contain ‚Äî like the attributes (e.g., name, color) and the behaviors (e.g., move, stop) of a car.
    </p>

    <figure class="concept-image">
      <img src="./assets/images/realworldexample.png" alt="Example of Class from real world object" />
      <figcaption class="caption">A real-world analogy: designing the idea of a car (class)</figcaption>
    </figure>

    <p>
      There are mainly two types of classes you‚Äôll hear about:
    </p>
    <ul>
      <li><strong>Concrete Classes</strong>: These are regular classes you can use to create real objects (instances).
      </li>
      <li><strong>Abstract Classes</strong>: These are incomplete classes that act like ideas or templates. You can't
        create objects from them directly ‚Äî they need more details first.</li>
    </ul>

    <figure class="concept-image">
      <img src="./assets/images/classtypes_.png" alt="Types of Class" />
      <figcaption class="caption">Concrete vs Abstract Class Overview</figcaption>
    </figure>

    <p><em>We‚Äôll explore abstract classes more in upcoming sections. üòä</em></p>
  </div>

  <!-- Objects -->
  <div class="objects cloud-box">
    <h1>Objects</h1>

    <p>
      An <strong>object</strong> is like a real-world thing created from a class blueprint. It holds actual values and
      can do things using the functions defined in the class.
    </p>

    <figure class="concept-image">
      <img src="./assets/images/object_example.png" alt="Example of Object from real world object" />
      <figcaption class="caption">A real-world car object made from the 'Car' class</figcaption>
    </figure>

    <p>
      There are two main ways to create objects in languages like C++:
    </p>

    <ol>
      <li>
        <strong>1. Stack Object Creation:</strong><br>
        This is when you create the object directly in memory. It gets destroyed automatically when it goes out of
        scope.
        <pre class="code-block"><code>// C++ example
class Car {
public:
    void drive() { /* ... */ }
};

int main() {
    Car myCar; // Stack object
    myCar.drive();
    // myCar is destroyed automatically
}
</code></pre>
      </li>

      <li>
        <strong>2. Dynamic Object Creation:</strong><br>
        This method gives you more control. You create the object using <code>new</code> and must manually delete it to
        avoid memory leaks.
        <pre class="code-block"><code>// C++ example
Car* myCarPtr = new Car(); // Dynamic object
myCarPtr->drive();
delete myCarPtr; // You must delete it manually
</code></pre>
      </li>
    </ol>

    <p>
      üîÅ In short: <strong>stack objects</strong> are easy to manage, while <strong>dynamic objects</strong> give you
      more control but require extra care.
    </p>
  </div>


  <div class="class_components cloud-box">
    <h1>Class Components</h1>

    <p>A class contains multiple components:</p>

    <ul>
      <li><strong>Attributes (or Properties):</strong> These are the data or characteristics of the class, like a car's
        color or model. They define what the object can hold.</li>
        <pre class="code-block"><code>// Attribute example
class Car {
  public:
    string color;
    int model;
};
</code></pre>
    </ul>

    <figure class="class_compo_image">
      <img src="./assets/images/data_member.png" alt="Data Members" width="300px" />
      <figcaption class="caption">Data Members (Attributes)</figcaption>
    </figure>

    <ul>
      <li><strong>Methods (or Functions):</strong> These are the actions or behaviors the class can perform, like
        starting the engine or honking the horn. They define what the object can do.</li>
    </ul>

    <figure class="class_compo_image">
      <img src="./assets/images/member_function.png" alt="Member Function"/>
      <figcaption class="caption">Member Function (Behaviour)</figcaption>
    </figure>

    <pre class="code-block"><code>// Method example
class Car {
  public:
    void honk() {
      cout << "Beep!";
    }
};
</code></pre>

    <ul>
      <li><strong>Constructors:</strong> These are special methods that run when you create an object. They set up the
        initial state of the object, like setting the car's color or model when you create a new car object.</li>
    </ul>

    <figure class="class_compo_image">
      <img src="./assets/images/constructor.png" alt="Constructor"  />
      <figcaption class="caption">Constructor Example</figcaption>
    </figure>

    <pre class="code-block"><code>// Constructor example
class Car {
  public:
    string color;
    Car(string c) {
      color = c;
    }
};
</code></pre>

    <ul>
      <li><strong>Destructors:</strong> These are special methods that run when an object is destroyed. They clean up
        resources or perform any necessary final actions, like releasing memory or closing files.</li>
    </ul>

    <figure class="class_compo_image">
      <img src="./assets/images/destructor.png" alt="Destructor"  />
      <figcaption class="caption">Destructor Example</figcaption>
    </figure>

    <pre class="code-block"><code>// Destructor example
class Car {
  public:
    ~Car() {
      // cleanup code
    }
};
</code></pre>


    <ul>
      <li><strong>Access Modifiers:</strong> These control how the class's attributes and methods can be accessed. They
        can be <strong>public</strong> (accessible from anywhere), <strong>private</strong> (accessible only within the
        class), or <strong>protected</strong> (accessible within the class and its subclasses).</li>
    </ul>

    <figure class="class_compo_image">
      <img src="./assets/images/access_modifier.png" alt="Access Modifier"  />
      <figcaption class="caption">Access Modifer and Who can Access Them</figcaption>
    </figure>

    <pre class="code-block"><code>// Access Modifiers example
class Car {
  private:
    int speed;
  public:
    void setSpeed(int s) { speed = s; }
};
</code></pre>

    <ul>
      <li><strong>Static Members and Functions:</strong> These belong to the class itself, not to any specific object. A
        <strong>static attribute</strong> is shared by all objects of the class, and a <strong>static method</strong>
        can be called without creating an object. For example, you might use a static variable to count how many objects
        have been created.</li>
    <pre class="code-block"><code>// Static Member/Function example
class Car {
  public:
    static int count;
    Car() { count++; }
    static void showCount() {
      cout << count;
    }
};
int Car::count = 0;
</code></pre>
    </ul>

    <ul>
      <li><strong>Friend Classes and Functions:</strong> These are special functions or classes that are allowed to
        access the private and protected members of another class. They are useful when two or more classes need to work
        closely together and share internal details, but you still want to keep those details hidden from the rest of
        the code.</li>
    <pre class="code-block"><code>// Friend Function example
class Box {
  private:
    int width;
  public:
    friend void setWidth(Box &b, int w);
};
void setWidth(Box &b, int w) {
  b.width = w;
}
</code></pre>
    </ul>
  </div>

  <!-- Inheritance -->
  <div class="inheritance cloud-box">
    <h1>Inheritance</h1>
    <p>
      <strong>Inheritance</strong> is like passing down traits from parents to children, but in code! It lets you create a new class (called a <strong>derived</strong> or <strong>child</strong> class) based on an existing class (the <strong>base</strong> or <strong>parent</strong> class). The child class automatically gets all the attributes and methods of the parent, and you can add more or change them as needed.
    </p>
    <p>
      This helps you avoid repeating code and makes it easier to organize related classes. For example, you can have <code>Mother</code> and <code>Father</code> classes, and then create a <code>Child</code> class that inherits from them.
    </p>

    <figure class="class_compo_image">
      <img src="./assets/images/inheritence_faily.png.png" alt="Inheritance Example with Family" width="400px"/>
      <figcaption class="caption">A Child inheriting traits from Mother and Father</figcaption>
    </figure>

    <h2>Types of Inheritance</h2>
    <ul>
      <li>
        <strong>Single Inheritance:</strong> A class inherits from one base class.<br>
        <em>Example: Child inherits only from Mother.</em>
        <pre class="code-block"><code>// Single Inheritance
class Mother {
  public:
    void hair_color() { /* ... */ }
};
class Child : public Mother {
  // Child gets hair_color() from Mother
};
</code></pre>
    <figure class="class_compo_image">
          <img src="./assets/images/single_inheritence.png" alt="Inheritance Example with Family"/>
          <figcaption class="caption">A Child inheriting hair_color traits from Mother</figcaption>
    </figure>
      </li>
      <li>
        <strong>Multiple Inheritance:</strong> A class inherits from more than one base class.<br>
        <em>Example: Child inherits from both Mother and Father.</em>
        <pre class="code-block"><code>// Multiple Inheritance
class Mother {
  public:
    void cook() { /* ... */ }
};
class Father {
  public:
    void drive() { /* ... */ }
};
class Child : public Mother, public Father {
  // Child gets cook() from Mother and drive() from Father
};
</code></pre>
    <figure class="class_compo_image">
          <img src="./assets/images/multiple_inheritence.png" alt="Inheritance Example with Family"/>
          <figcaption class="caption">A Child inheriting "drive" trait from Father and "cook" trait from Mother</figcaption>
    </figure>
      </li>
      <li>
        <strong>Multilevel Inheritance:</strong> A class is derived from another derived class (like a chain).<br>
        <em>Example: Grandmother ‚Üí Mother ‚Üí Child.</em>
        <pre class="code-block"><code>// Multilevel Inheritance
class Grandmother {
  public:
    void cook() { /* ... */ }
};
class Mother : public Grandmother {
  // inherits cook()
};
class Child : public Mother {
  // inherits cook() from Grandmother through Mother
};
</code></pre>
    <figure class="class_compo_image">
          <img src="./assets/images/multilevel_inheritence.png" alt="Inheritance Example with Family"/>
          <figcaption class="caption">A Child inheriting "cook" trait from Mother which is inherited from GrandMother</figcaption>
    </figure>
      </li>
      <li>
        <strong>Hierarchical Inheritance:</strong> Multiple classes inherit from the same base class.<br>
        <em>Example: Both Son and Daughter inherit from Mother.</em>
        <pre class="code-block"><code>// Hierarchical Inheritance
class Mother {
  public:
    void hair_type() { /* ... */ }
};
class Son : public Mother { /* ... */ };
class Daughter : public Mother { /* ... */ };
// Both Son and Daughter get thick hair()
</code></pre>
    <figure class="class_compo_image">
          <img src="./assets/images/heirarchial_inheritence.png" alt="Inheritance Example with Family"/>
          <figcaption class="caption">Both Son and Daughter get hair type from Mother</figcaption>
    </figure>
      </li>
      <li>
        <strong>Hybrid Inheritance:</strong> A combination of two or more types of inheritance.<br>
        <em>Example: A <b>ColoredRectangle</b> class inherits from both <b>Rectangle</b> (which inherits from <b>Shape</b>) and <b>Color</b>.</em>
        <pre class="code-block"><code>// Hybrid Inheritance Example
class Shape { /* ... */ };
class Rectangle : public Shape { /* ... */ };
class Color { /* ... */ };
class ColoredRectangle : public Rectangle, public Color { /* ... */ };
// ColoredRectangle inherits from both Rectangle (which inherits Shape) and Color
</code></pre>
      </li>
      <figure class="class_compo_image">
          <img src="./assets/images/hybrid_inheritence.png" alt="Inheritance Example with Family"/>
          <figcaption class="caption">Exmaple of Hybrid Inheritence</figcaption>
    </figure>
    </ul>

    <h2>The Diamond Problem</h2>
    <p>
      Sometimes, multiple inheritance can cause confusion. Imagine both <code>Mother</code> and <code>Father</code> inherit from <code>Grandmother</code>, and then <code>Child</code> inherits from both <code>Mother</code> and <code>Father</code>. Now, <code>Child</code> has two copies of <code>Grandmother</code>! This is called the <strong>diamond problem</strong>.
    </p>
    <figure class="concept-image">
      <img src="./assets/images/diamond_problem_family.png" alt="Diamond Problem with Family" />
      <figcaption class="caption">The Diamond Problem: Child gets two Grandmothers!</figcaption>
    </figure>
    <pre class="code-block"><code>// Diamond Problem Example
class Grandmother { public: void cook() { /* ... */ } };
class Mother : public Grandmother { };
class Father : public Grandmother { };
class Child : public Mother, public Father { };
// Child has two copies of Grandmother::cook()
</code></pre>

    <h2>Solving the Diamond Problem</h2>
    <p>
      To fix this, C++ lets you use <strong>virtual base classes</strong>. By declaring the inheritance as <code>virtual</code>, you make sure only one copy of the base class is shared, no matter how many times it appears in the hierarchy.
    </p>
    <pre class="code-block"><code>// Solution with Virtual Base Class
class Grandmother { public: void cook() { /* ... */ } };
class Mother : virtual public Grandmother { };
class Father : virtual public Grandmother { };
class Child : public Mother, public Father { };
// Only one copy of Grandmother in Child
</code></pre>
    <p>
      If you ever need to specify which parent's method to use (in case of ambiguity), you can use the <strong>scope resolution operator</strong> (<code>::</code>):
    </p>
    <pre class="code-block"><code>// Using scope resolution
child.Mother::cook(); // Calls cook() from Mother's Grandmother
child.Father::cook(); // Calls cook() from Father's Grandmother
</code></pre>
    <p>
      <em>In summary: inheritance helps you reuse code, but be careful with multiple inheritance! Virtual base classes and the scope resolution operator help you avoid confusion and keep things tidy‚Äîeven in a big family tree.</em>
    </p>
  </div>


  <div class="note2">
    <strong>Quick Recap of OOP Concepts</strong>

    <p style="font-style: italic; margin-bottom: 16px; color: #6c4f00;">
      ‚ú® You can <strong>zoom in or out</strong> using your mouse scroll wheel, and <strong>click and drag</strong> the
      diagram to explore different parts. It‚Äôs like moving around a real whiteboard ‚Äî helpful for revising all the key
      concepts at your own pace!
    </p>

    <div id="svg-viewer"
      style="width: 100%; max-width: 900px; height: 500px; overflow: hidden; position: relative; border: 2px solid #ccc; border-radius: 12px; margin: 20px auto;">

      <div id="transform-wrapper" style="transform: scale(0.9); transform-origin: center; cursor: grab;">
        <img id="zoomable-image" src="./assets/exclidraw_items/oops.svg" alt="OOP Recap" width="900" height="600"
          style="display: block;" />
      </div>

    </div>
  </div>

  <script src="../assets/js/oops_index.js"></script>
</body>

</html>
